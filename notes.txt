One of the ways to solve circular dependancies is to move the 
offending module(import) to the bottom. 

@app.route() -> decorator allows assignment of more than on url to a view function

add top level script that represents the application will be microblog.py

---

since there are no users yet, to build a new app with feature which doesnt exist,
use dummy variables/users/data to build base of the feature. 

-- using jinja2, both {{user.username}}, {{user['username']}} works. 

flask apps configs can be done as keys in app.config[''] ways
or to enforce the principle of 'seperation of concerns', 
using a slighly more elaborate structure, keep configs in a seperate file. 
--its extensible using python class to store configs
--seperate module gives better organization of files
-- this way cann add/remove configs,
--if more than one config set, can create subclasses. 

- Flask and some of its extensions use secret key as a cryptographic key,
 useful to generate signatures or tokens, 
 -wtf uses it to protect forms against CSRF (seasurf)
 cross site request forgery

